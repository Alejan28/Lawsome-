{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nimport { db, storage } from '../InitApp/firebase';\nimport { collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, doc, updateDoc, deleteDoc, getDocs } from 'firebase/firestore';\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\nexport const useChatHistory = userId => {\n  _s();\n  const [conversations, setConversations] = useState([]);\n  const [currentConversationId, setCurrentConversationId] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [usingLocal, setUsingLocal] = useState(false);\n\n  // Ref to track current conversation ID across async operations and stale closures\n  const conversationIdRef = useRef(null);\n\n  // Sync ref with state\n  useEffect(() => {\n    conversationIdRef.current = currentConversationId;\n  }, [currentConversationId]);\n\n  // 1. Load Conversations List\n  useEffect(() => {\n    if (!userId) {\n      setConversations([]);\n      setLoading(false);\n      return;\n    }\n    const q = query(collection(db, 'users', userId, 'conversations'), orderBy('updatedAt', 'desc'));\n    const unsubscribe = onSnapshot(q, snapshot => {\n      const convs = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setConversations(convs);\n      setLoading(false);\n      setUsingLocal(false);\n    }, error => {\n      console.warn(\"Firestore access failed. Falling back to localStorage.\", error);\n      setUsingLocal(true);\n      try {\n        const localConvs = JSON.parse(localStorage.getItem(`conversations_${userId}`) || \"[]\");\n        setConversations(localConvs);\n      } catch (e) {\n        console.error(e);\n      }\n      setLoading(false);\n    });\n    return () => unsubscribe();\n  }, [userId]);\n\n  // 2. Load Messages for Current Conversation\n  useEffect(() => {\n    if (!userId || !currentConversationId) {\n      setMessages([]);\n      return;\n    }\n    if (usingLocal) {\n      try {\n        const localMsgs = JSON.parse(localStorage.getItem(`messages_${currentConversationId}`) || \"[]\");\n        setMessages(localMsgs);\n      } catch (e) {\n        console.error(e);\n      }\n      return;\n    }\n    const q = query(collection(db, 'users', userId, 'conversations', currentConversationId, 'messages'), orderBy('timestamp', 'asc'));\n    const unsubscribe = onSnapshot(q, snapshot => {\n      const msgs = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMessages(msgs);\n    });\n    return () => unsubscribe();\n  }, [userId, currentConversationId, usingLocal]);\n\n  // 3. Start New Conversation\n  const startNewConversation = async (title = \"Conversație Nouă\", mode = \"generation\") => {\n    if (!userId) return;\n    const newConv = {\n      title,\n      mode,\n      createdAt: usingLocal ? Date.now() : serverTimestamp(),\n      updatedAt: usingLocal ? Date.now() : serverTimestamp(),\n      lastMessage: \"Început de conversație\"\n    };\n    if (usingLocal) {\n      const id = \"local_\" + Date.now();\n      const updatedConvs = [{\n        id,\n        ...newConv,\n        createdAt: Date.now(),\n        updatedAt: Date.now()\n      }, ...conversations];\n      localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\n      setConversations(updatedConvs);\n      setCurrentConversationId(id);\n      conversationIdRef.current = id; // Update ref immediately\n      return id;\n    } else {\n      try {\n        const docRef = await addDoc(collection(db, 'users', userId, 'conversations'), newConv);\n        setCurrentConversationId(docRef.id);\n        conversationIdRef.current = docRef.id; // Update ref immediately\n        return docRef.id;\n      } catch (e) {\n        console.error(\"Error creating conversation, switching to local\", e);\n        setUsingLocal(true);\n        // Retry locally\n        return startNewConversation(title, mode);\n      }\n    }\n  };\n\n  // 4. Send Message\n  const saveMessage = async (message, mode = \"generation\") => {\n    if (!userId) return;\n\n    // Use ref to get the latest ID, avoiding stale closure issues\n    let activeId = conversationIdRef.current;\n    if (!activeId) {\n      // Auto-create conversation if none selected\n      const title = message.text.substring(0, 30) + (message.text.length > 30 ? \"...\" : \"\");\n      activeId = await startNewConversation(title, mode);\n      // startNewConversation updates the ref, so we are good\n    }\n    let fileUrl = null;\n    if (message.fileBlob && !usingLocal) {\n      try {\n        const storageRef = ref(storage, `chat_files/${userId}/${Date.now()}_document.docx`);\n        await uploadBytes(storageRef, message.fileBlob);\n        fileUrl = await getDownloadURL(storageRef);\n      } catch (e) {\n        console.error(\"File upload failed\", e);\n      }\n    }\n    const msgData = {\n      text: message.text,\n      sender: message.sender,\n      timestamp: usingLocal ? Date.now() : serverTimestamp(),\n      fileUrl: fileUrl || null\n    };\n    if (usingLocal) {\n      const localMsgs = JSON.parse(localStorage.getItem(`messages_${activeId}`) || \"[]\");\n      const newMsgs = [...localMsgs, {\n        ...msgData,\n        timestamp: Date.now()\n      }];\n      localStorage.setItem(`messages_${activeId}`, JSON.stringify(newMsgs));\n      setMessages(newMsgs);\n      const updatedConvs = conversations.map(c => c.id === activeId ? {\n        ...c,\n        lastMessage: message.text,\n        updatedAt: Date.now()\n      } : c);\n      localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\n      setConversations(updatedConvs);\n    } else {\n      try {\n        await addDoc(collection(db, 'users', userId, 'conversations', activeId, 'messages'), msgData);\n        await updateDoc(doc(db, 'users', userId, 'conversations', activeId), {\n          lastMessage: message.text,\n          updatedAt: serverTimestamp()\n        });\n      } catch (e) {\n        console.error(\"Error sending message\", e);\n      }\n    }\n  };\n  const selectConversation = id => {\n    setCurrentConversationId(id);\n    conversationIdRef.current = id;\n  };\n  const deleteConversation = async conversationId => {\n    if (!userId) return;\n    if (usingLocal) {\n      const updatedConvs = conversations.filter(c => c.id !== conversationId);\n      localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\n      setConversations(updatedConvs);\n      localStorage.removeItem(`messages_${conversationId}`);\n    } else {\n      try {\n        // Delete messages subcollection (client-side manual delete)\n        const messagesRef = collection(db, 'users', userId, 'conversations', conversationId, 'messages');\n        const snapshot = await getDocs(messagesRef);\n        const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));\n        await Promise.all(deletePromises);\n\n        // Delete conversation doc\n        await deleteDoc(doc(db, 'users', userId, 'conversations', conversationId));\n      } catch (error) {\n        console.error(\"Error deleting conversation:\", error);\n      }\n    }\n\n    // If the deleted conversation was active, reset\n    if (currentConversationId === conversationId) {\n      setCurrentConversationId(null);\n      conversationIdRef.current = null;\n      setMessages([]);\n    }\n  };\n  return {\n    conversations,\n    currentConversationId,\n    messages,\n    loading,\n    saveMessage,\n    startNewConversation,\n    selectConversation,\n    deleteConversation\n  };\n};\n_s(useChatHistory, \"zt4/IIzWcdG2DUbIbKQ5psF8/Zw=\");","map":{"version":3,"names":["useState","useEffect","useRef","db","storage","collection","query","orderBy","onSnapshot","addDoc","serverTimestamp","doc","updateDoc","deleteDoc","getDocs","ref","uploadBytes","getDownloadURL","useChatHistory","userId","_s","conversations","setConversations","currentConversationId","setCurrentConversationId","messages","setMessages","loading","setLoading","usingLocal","setUsingLocal","conversationIdRef","current","q","unsubscribe","snapshot","convs","docs","map","id","data","error","console","warn","localConvs","JSON","parse","localStorage","getItem","e","localMsgs","msgs","startNewConversation","title","mode","newConv","createdAt","Date","now","updatedAt","lastMessage","updatedConvs","setItem","stringify","docRef","saveMessage","message","activeId","text","substring","length","fileUrl","fileBlob","storageRef","msgData","sender","timestamp","newMsgs","c","selectConversation","deleteConversation","conversationId","filter","removeItem","messagesRef","deletePromises","Promise","all"],"sources":["C:/Users/40741/IdeaProjects/lawsome-app/src/hooks/useChatHistory.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\r\nimport { db, storage } from '../InitApp/firebase';\r\nimport { collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, doc, updateDoc, deleteDoc, getDocs } from 'firebase/firestore';\r\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\r\n\r\nexport const useChatHistory = (userId) => {\r\n    const [conversations, setConversations] = useState([]);\r\n    const [currentConversationId, setCurrentConversationId] = useState(null);\r\n    const [messages, setMessages] = useState([]);\r\n    const [loading, setLoading] = useState(true);\r\n    const [usingLocal, setUsingLocal] = useState(false);\r\n    \r\n    // Ref to track current conversation ID across async operations and stale closures\r\n    const conversationIdRef = useRef(null);\r\n\r\n    // Sync ref with state\r\n    useEffect(() => {\r\n        conversationIdRef.current = currentConversationId;\r\n    }, [currentConversationId]);\r\n\r\n    // 1. Load Conversations List\r\n    useEffect(() => {\r\n        if (!userId) {\r\n            setConversations([]);\r\n            setLoading(false);\r\n            return;\r\n        }\r\n\r\n        const q = query(\r\n            collection(db, 'users', userId, 'conversations'),\r\n            orderBy('updatedAt', 'desc')\r\n        );\r\n\r\n        const unsubscribe = onSnapshot(q, (snapshot) => {\r\n            const convs = snapshot.docs.map(doc => ({\r\n                id: doc.id,\r\n                ...doc.data()\r\n            }));\r\n            setConversations(convs);\r\n            setLoading(false);\r\n            setUsingLocal(false);\r\n        }, (error) => {\r\n            console.warn(\"Firestore access failed. Falling back to localStorage.\", error);\r\n            setUsingLocal(true);\r\n            try {\r\n                const localConvs = JSON.parse(localStorage.getItem(`conversations_${userId}`) || \"[]\");\r\n                setConversations(localConvs);\r\n            } catch (e) { console.error(e); }\r\n            setLoading(false);\r\n        });\r\n\r\n        return () => unsubscribe();\r\n    }, [userId]);\r\n\r\n    // 2. Load Messages for Current Conversation\r\n    useEffect(() => {\r\n        if (!userId || !currentConversationId) {\r\n            setMessages([]);\r\n            return;\r\n        }\r\n\r\n        if (usingLocal) {\r\n            try {\r\n                const localMsgs = JSON.parse(localStorage.getItem(`messages_${currentConversationId}`) || \"[]\");\r\n                setMessages(localMsgs);\r\n            } catch (e) { console.error(e); }\r\n            return;\r\n        }\r\n\r\n        const q = query(\r\n            collection(db, 'users', userId, 'conversations', currentConversationId, 'messages'),\r\n            orderBy('timestamp', 'asc')\r\n        );\r\n\r\n        const unsubscribe = onSnapshot(q, (snapshot) => {\r\n            const msgs = snapshot.docs.map(doc => ({\r\n                id: doc.id,\r\n                ...doc.data()\r\n            }));\r\n            setMessages(msgs);\r\n        });\r\n\r\n        return () => unsubscribe();\r\n    }, [userId, currentConversationId, usingLocal]);\r\n\r\n    // 3. Start New Conversation\r\n    const startNewConversation = async (title = \"Conversație Nouă\", mode = \"generation\") => {\r\n        if (!userId) return;\r\n        \r\n        const newConv = {\r\n            title,\r\n            mode,\r\n            createdAt: usingLocal ? Date.now() : serverTimestamp(),\r\n            updatedAt: usingLocal ? Date.now() : serverTimestamp(),\r\n            lastMessage: \"Început de conversație\"\r\n        };\r\n\r\n        if (usingLocal) {\r\n            const id = \"local_\" + Date.now();\r\n            const updatedConvs = [{ id, ...newConv, createdAt: Date.now(), updatedAt: Date.now() }, ...conversations];\r\n            localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\r\n            setConversations(updatedConvs);\r\n            \r\n            setCurrentConversationId(id);\r\n            conversationIdRef.current = id; // Update ref immediately\r\n            return id;\r\n        } else {\r\n            try {\r\n                const docRef = await addDoc(collection(db, 'users', userId, 'conversations'), newConv);\r\n                setCurrentConversationId(docRef.id);\r\n                conversationIdRef.current = docRef.id; // Update ref immediately\r\n                return docRef.id;\r\n            } catch (e) {\r\n                console.error(\"Error creating conversation, switching to local\", e);\r\n                setUsingLocal(true);\r\n                // Retry locally\r\n                return startNewConversation(title, mode);\r\n            }\r\n        }\r\n    };\r\n\r\n    // 4. Send Message\r\n    const saveMessage = async (message, mode = \"generation\") => {\r\n        if (!userId) return;\r\n\r\n        // Use ref to get the latest ID, avoiding stale closure issues\r\n        let activeId = conversationIdRef.current;\r\n        \r\n        if (!activeId) {\r\n            // Auto-create conversation if none selected\r\n            const title = message.text.substring(0, 30) + (message.text.length > 30 ? \"...\" : \"\");\r\n            activeId = await startNewConversation(title, mode);\r\n            // startNewConversation updates the ref, so we are good\r\n        }\r\n\r\n        let fileUrl = null;\r\n        if (message.fileBlob && !usingLocal) {\r\n             try {\r\n                const storageRef = ref(storage, `chat_files/${userId}/${Date.now()}_document.docx`);\r\n                await uploadBytes(storageRef, message.fileBlob);\r\n                fileUrl = await getDownloadURL(storageRef);\r\n            } catch (e) { console.error(\"File upload failed\", e); }\r\n        }\r\n\r\n        const msgData = {\r\n            text: message.text,\r\n            sender: message.sender,\r\n            timestamp: usingLocal ? Date.now() : serverTimestamp(),\r\n            fileUrl: fileUrl || null\r\n        };\r\n\r\n        if (usingLocal) {\r\n            const localMsgs = JSON.parse(localStorage.getItem(`messages_${activeId}`) || \"[]\");\r\n            const newMsgs = [...localMsgs, { ...msgData, timestamp: Date.now() }];\r\n            localStorage.setItem(`messages_${activeId}`, JSON.stringify(newMsgs));\r\n            setMessages(newMsgs);\r\n\r\n            const updatedConvs = conversations.map(c => \r\n                c.id === activeId ? { ...c, lastMessage: message.text, updatedAt: Date.now() } : c\r\n            );\r\n            localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\r\n            setConversations(updatedConvs);\r\n        } else {\r\n            try {\r\n                await addDoc(collection(db, 'users', userId, 'conversations', activeId, 'messages'), msgData);\r\n                await updateDoc(doc(db, 'users', userId, 'conversations', activeId), {\r\n                    lastMessage: message.text,\r\n                    updatedAt: serverTimestamp()\r\n                });\r\n            } catch (e) {\r\n                console.error(\"Error sending message\", e);\r\n            }\r\n        }\r\n    };\r\n\r\n    const selectConversation = (id) => {\r\n        setCurrentConversationId(id);\r\n        conversationIdRef.current = id;\r\n    };\r\n\r\n    const deleteConversation = async (conversationId) => {\r\n        if (!userId) return;\r\n\r\n        if (usingLocal) {\r\n            const updatedConvs = conversations.filter(c => c.id !== conversationId);\r\n            localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\r\n            setConversations(updatedConvs);\r\n            localStorage.removeItem(`messages_${conversationId}`);\r\n        } else {\r\n            try {\r\n                // Delete messages subcollection (client-side manual delete)\r\n                const messagesRef = collection(db, 'users', userId, 'conversations', conversationId, 'messages');\r\n                const snapshot = await getDocs(messagesRef);\r\n                const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));\r\n                await Promise.all(deletePromises);\r\n\r\n                // Delete conversation doc\r\n                await deleteDoc(doc(db, 'users', userId, 'conversations', conversationId));\r\n            } catch (error) {\r\n                console.error(\"Error deleting conversation:\", error);\r\n            }\r\n        }\r\n\r\n        // If the deleted conversation was active, reset\r\n        if (currentConversationId === conversationId) {\r\n            setCurrentConversationId(null);\r\n            conversationIdRef.current = null;\r\n            setMessages([]);\r\n        }\r\n    };\r\n\r\n    return { \r\n        conversations, \r\n        currentConversationId, \r\n        messages, \r\n        loading, \r\n        saveMessage, \r\n        startNewConversation, \r\n        selectConversation,\r\n        deleteConversation\r\n    };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
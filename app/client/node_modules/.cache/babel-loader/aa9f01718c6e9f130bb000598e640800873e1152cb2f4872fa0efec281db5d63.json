{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nimport { db, storage } from '../InitApp/firebase';\nimport { collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, doc, updateDoc, deleteDoc, getDocs } from 'firebase/firestore';\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\nexport const useChatHistory = userId => {\n  _s();\n  const [conversations, setConversations] = useState([]);\n  const [currentConversationId, setCurrentConversationId] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [usingLocal, setUsingLocal] = useState(false);\n\n  // Ref to track current conversation ID across async operations and stale closures\n  const conversationIdRef = useRef(null);\n\n  // Sync ref with state\n  useEffect(() => {\n    conversationIdRef.current = currentConversationId;\n  }, [currentConversationId]);\n\n  // 1. Load Conversations List\n  useEffect(() => {\n    if (!userId) {\n      setConversations([]);\n      setLoading(false);\n      return;\n    }\n    const q = query(collection(db, 'users', userId, 'conversations'), orderBy('updatedAt', 'desc'));\n    const unsubscribe = onSnapshot(q, snapshot => {\n      const convs = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setConversations(convs);\n      setLoading(false);\n      setUsingLocal(false);\n    }, error => {\n      console.warn(\"Firestore access failed. Falling back to localStorage.\", error);\n      setUsingLocal(true);\n      try {\n        const localConvs = JSON.parse(localStorage.getItem(`conversations_${userId}`) || \"[]\");\n        setConversations(localConvs);\n      } catch (e) {\n        console.error(e);\n      }\n      setLoading(false);\n    });\n    return () => unsubscribe();\n  }, [userId]);\n\n  // 2. Load Messages for Current Conversation\n  useEffect(() => {\n    if (!userId || !currentConversationId) {\n      setMessages([]);\n      return;\n    }\n    if (usingLocal) {\n      try {\n        const localMsgs = JSON.parse(localStorage.getItem(`messages_${currentConversationId}`) || \"[]\");\n        setMessages(localMsgs);\n      } catch (e) {\n        console.error(e);\n      }\n      return;\n    }\n    const q = query(collection(db, 'users', userId, 'conversations', currentConversationId, 'messages'), orderBy('timestamp', 'asc'));\n    const unsubscribe = onSnapshot(q, snapshot => {\n      const msgs = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMessages(msgs);\n    });\n    return () => unsubscribe();\n  }, [userId, currentConversationId, usingLocal]);\n\n  // 3. Start New Conversation\n  const startNewConversation = async (title = \"Conversație Nouă\") => {\n    if (!userId) return;\n    const newConv = {\n      title,\n      createdAt: usingLocal ? Date.now() : serverTimestamp(),\n      updatedAt: usingLocal ? Date.now() : serverTimestamp(),\n      lastMessage: \"Început de conversație\"\n    };\n    if (usingLocal) {\n      const id = \"local_\" + Date.now();\n      const updatedConvs = [{\n        id,\n        ...newConv,\n        createdAt: Date.now(),\n        updatedAt: Date.now()\n      }, ...conversations];\n      localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\n      setConversations(updatedConvs);\n      setCurrentConversationId(id);\n      conversationIdRef.current = id; // Update ref immediately\n      return id;\n    } else {\n      try {\n        const docRef = await addDoc(collection(db, 'users', userId, 'conversations'), newConv);\n        setCurrentConversationId(docRef.id);\n        conversationIdRef.current = docRef.id; // Update ref immediately\n        return docRef.id;\n      } catch (e) {\n        console.error(\"Error creating conversation, switching to local\", e);\n        setUsingLocal(true);\n        // Retry locally\n        return startNewConversation(title);\n      }\n    }\n  };\n\n  // 4. Send Message\n  const saveMessage = async message => {\n    if (!userId) return;\n\n    // Use ref to get the latest ID, avoiding stale closure issues\n    let activeId = conversationIdRef.current;\n    if (!activeId) {\n      // Auto-create conversation if none selected\n      const title = message.text.substring(0, 30) + (message.text.length > 30 ? \"...\" : \"\");\n      activeId = await startNewConversation(title);\n      // startNewConversation updates the ref, so we are good\n    }\n    let fileUrl = null;\n    if (message.fileBlob && !usingLocal) {\n      try {\n        const storageRef = ref(storage, `chat_files/${userId}/${Date.now()}_document.docx`);\n        await uploadBytes(storageRef, message.fileBlob);\n        fileUrl = await getDownloadURL(storageRef);\n      } catch (e) {\n        console.error(\"File upload failed\", e);\n      }\n    }\n    const msgData = {\n      text: message.text,\n      sender: message.sender,\n      timestamp: usingLocal ? Date.now() : serverTimestamp(),\n      fileUrl: fileUrl || null\n    };\n    if (usingLocal) {\n      const localMsgs = JSON.parse(localStorage.getItem(`messages_${activeId}`) || \"[]\");\n      const newMsgs = [...localMsgs, {\n        ...msgData,\n        timestamp: Date.now()\n      }];\n      localStorage.setItem(`messages_${activeId}`, JSON.stringify(newMsgs));\n      setMessages(newMsgs);\n      const updatedConvs = conversations.map(c => c.id === activeId ? {\n        ...c,\n        lastMessage: message.text,\n        updatedAt: Date.now()\n      } : c);\n      localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\n      setConversations(updatedConvs);\n    } else {\n      try {\n        await addDoc(collection(db, 'users', userId, 'conversations', activeId, 'messages'), msgData);\n        await updateDoc(doc(db, 'users', userId, 'conversations', activeId), {\n          lastMessage: message.text,\n          updatedAt: serverTimestamp()\n        });\n      } catch (e) {\n        console.error(\"Error sending message\", e);\n      }\n    }\n  };\n  const selectConversation = id => {\n    setCurrentConversationId(id);\n    conversationIdRef.current = id;\n  };\n  const deleteConversation = async conversationId => {\n    if (!userId) return;\n    if (usingLocal) {\n      const updatedConvs = conversations.filter(c => c.id !== conversationId);\n      localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\n      setConversations(updatedConvs);\n      localStorage.removeItem(`messages_${conversationId}`);\n    } else {\n      try {\n        // Delete messages subcollection (client-side manual delete)\n        const messagesRef = collection(db, 'users', userId, 'conversations', conversationId, 'messages');\n        const snapshot = await getDocs(messagesRef);\n        const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));\n        await Promise.all(deletePromises);\n\n        // Delete conversation doc\n        await deleteDoc(doc(db, 'users', userId, 'conversations', conversationId));\n      } catch (error) {\n        console.error(\"Error deleting conversation:\", error);\n      }\n    }\n\n    // If the deleted conversation was active, reset\n    if (currentConversationId === conversationId) {\n      setCurrentConversationId(null);\n      conversationIdRef.current = null;\n      setMessages([]);\n    }\n  };\n  return {\n    conversations,\n    currentConversationId,\n    messages,\n    loading,\n    saveMessage,\n    startNewConversation,\n    selectConversation,\n    deleteConversation\n  };\n};\n_s(useChatHistory, \"zt4/IIzWcdG2DUbIbKQ5psF8/Zw=\");","map":{"version":3,"names":["useState","useEffect","useRef","db","storage","collection","query","orderBy","onSnapshot","addDoc","serverTimestamp","doc","updateDoc","deleteDoc","getDocs","ref","uploadBytes","getDownloadURL","useChatHistory","userId","_s","conversations","setConversations","currentConversationId","setCurrentConversationId","messages","setMessages","loading","setLoading","usingLocal","setUsingLocal","conversationIdRef","current","q","unsubscribe","snapshot","convs","docs","map","id","data","error","console","warn","localConvs","JSON","parse","localStorage","getItem","e","localMsgs","msgs","startNewConversation","title","newConv","createdAt","Date","now","updatedAt","lastMessage","updatedConvs","setItem","stringify","docRef","saveMessage","message","activeId","text","substring","length","fileUrl","fileBlob","storageRef","msgData","sender","timestamp","newMsgs","c","selectConversation","deleteConversation","conversationId","filter","removeItem","messagesRef","deletePromises","Promise","all"],"sources":["C:/Users/40741/IdeaProjects/lawsome-app/src/hooks/useChatHistory.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\r\nimport { db, storage } from '../InitApp/firebase';\r\nimport { collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, doc, updateDoc, deleteDoc, getDocs } from 'firebase/firestore';\r\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\r\n\r\nexport const useChatHistory = (userId) => {\r\n    const [conversations, setConversations] = useState([]);\r\n    const [currentConversationId, setCurrentConversationId] = useState(null);\r\n    const [messages, setMessages] = useState([]);\r\n    const [loading, setLoading] = useState(true);\r\n    const [usingLocal, setUsingLocal] = useState(false);\r\n    \r\n    // Ref to track current conversation ID across async operations and stale closures\r\n    const conversationIdRef = useRef(null);\r\n\r\n    // Sync ref with state\r\n    useEffect(() => {\r\n        conversationIdRef.current = currentConversationId;\r\n    }, [currentConversationId]);\r\n\r\n    // 1. Load Conversations List\r\n    useEffect(() => {\r\n        if (!userId) {\r\n            setConversations([]);\r\n            setLoading(false);\r\n            return;\r\n        }\r\n\r\n        const q = query(\r\n            collection(db, 'users', userId, 'conversations'),\r\n            orderBy('updatedAt', 'desc')\r\n        );\r\n\r\n        const unsubscribe = onSnapshot(q, (snapshot) => {\r\n            const convs = snapshot.docs.map(doc => ({\r\n                id: doc.id,\r\n                ...doc.data()\r\n            }));\r\n            setConversations(convs);\r\n            setLoading(false);\r\n            setUsingLocal(false);\r\n        }, (error) => {\r\n            console.warn(\"Firestore access failed. Falling back to localStorage.\", error);\r\n            setUsingLocal(true);\r\n            try {\r\n                const localConvs = JSON.parse(localStorage.getItem(`conversations_${userId}`) || \"[]\");\r\n                setConversations(localConvs);\r\n            } catch (e) { console.error(e); }\r\n            setLoading(false);\r\n        });\r\n\r\n        return () => unsubscribe();\r\n    }, [userId]);\r\n\r\n    // 2. Load Messages for Current Conversation\r\n    useEffect(() => {\r\n        if (!userId || !currentConversationId) {\r\n            setMessages([]);\r\n            return;\r\n        }\r\n\r\n        if (usingLocal) {\r\n            try {\r\n                const localMsgs = JSON.parse(localStorage.getItem(`messages_${currentConversationId}`) || \"[]\");\r\n                setMessages(localMsgs);\r\n            } catch (e) { console.error(e); }\r\n            return;\r\n        }\r\n\r\n        const q = query(\r\n            collection(db, 'users', userId, 'conversations', currentConversationId, 'messages'),\r\n            orderBy('timestamp', 'asc')\r\n        );\r\n\r\n        const unsubscribe = onSnapshot(q, (snapshot) => {\r\n            const msgs = snapshot.docs.map(doc => ({\r\n                id: doc.id,\r\n                ...doc.data()\r\n            }));\r\n            setMessages(msgs);\r\n        });\r\n\r\n        return () => unsubscribe();\r\n    }, [userId, currentConversationId, usingLocal]);\r\n\r\n    // 3. Start New Conversation\r\n    const startNewConversation = async (title = \"Conversație Nouă\") => {\r\n        if (!userId) return;\r\n        \r\n        const newConv = {\r\n            title,\r\n            createdAt: usingLocal ? Date.now() : serverTimestamp(),\r\n            updatedAt: usingLocal ? Date.now() : serverTimestamp(),\r\n            lastMessage: \"Început de conversație\"\r\n        };\r\n\r\n        if (usingLocal) {\r\n            const id = \"local_\" + Date.now();\r\n            const updatedConvs = [{ id, ...newConv, createdAt: Date.now(), updatedAt: Date.now() }, ...conversations];\r\n            localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\r\n            setConversations(updatedConvs);\r\n            \r\n            setCurrentConversationId(id);\r\n            conversationIdRef.current = id; // Update ref immediately\r\n            return id;\r\n        } else {\r\n            try {\r\n                const docRef = await addDoc(collection(db, 'users', userId, 'conversations'), newConv);\r\n                setCurrentConversationId(docRef.id);\r\n                conversationIdRef.current = docRef.id; // Update ref immediately\r\n                return docRef.id;\r\n            } catch (e) {\r\n                console.error(\"Error creating conversation, switching to local\", e);\r\n                setUsingLocal(true);\r\n                // Retry locally\r\n                return startNewConversation(title);\r\n            }\r\n        }\r\n    };\r\n\r\n    // 4. Send Message\r\n    const saveMessage = async (message) => {\r\n        if (!userId) return;\r\n\r\n        // Use ref to get the latest ID, avoiding stale closure issues\r\n        let activeId = conversationIdRef.current;\r\n        \r\n        if (!activeId) {\r\n            // Auto-create conversation if none selected\r\n            const title = message.text.substring(0, 30) + (message.text.length > 30 ? \"...\" : \"\");\r\n            activeId = await startNewConversation(title);\r\n            // startNewConversation updates the ref, so we are good\r\n        }\r\n\r\n        let fileUrl = null;\r\n        if (message.fileBlob && !usingLocal) {\r\n             try {\r\n                const storageRef = ref(storage, `chat_files/${userId}/${Date.now()}_document.docx`);\r\n                await uploadBytes(storageRef, message.fileBlob);\r\n                fileUrl = await getDownloadURL(storageRef);\r\n            } catch (e) { console.error(\"File upload failed\", e); }\r\n        }\r\n\r\n        const msgData = {\r\n            text: message.text,\r\n            sender: message.sender,\r\n            timestamp: usingLocal ? Date.now() : serverTimestamp(),\r\n            fileUrl: fileUrl || null\r\n        };\r\n\r\n        if (usingLocal) {\r\n            const localMsgs = JSON.parse(localStorage.getItem(`messages_${activeId}`) || \"[]\");\r\n            const newMsgs = [...localMsgs, { ...msgData, timestamp: Date.now() }];\r\n            localStorage.setItem(`messages_${activeId}`, JSON.stringify(newMsgs));\r\n            setMessages(newMsgs);\r\n\r\n            const updatedConvs = conversations.map(c => \r\n                c.id === activeId ? { ...c, lastMessage: message.text, updatedAt: Date.now() } : c\r\n            );\r\n            localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\r\n            setConversations(updatedConvs);\r\n        } else {\r\n            try {\r\n                await addDoc(collection(db, 'users', userId, 'conversations', activeId, 'messages'), msgData);\r\n                await updateDoc(doc(db, 'users', userId, 'conversations', activeId), {\r\n                    lastMessage: message.text,\r\n                    updatedAt: serverTimestamp()\r\n                });\r\n            } catch (e) {\r\n                console.error(\"Error sending message\", e);\r\n            }\r\n        }\r\n    };\r\n\r\n    const selectConversation = (id) => {\r\n        setCurrentConversationId(id);\r\n        conversationIdRef.current = id;\r\n    };\r\n\r\n    const deleteConversation = async (conversationId) => {\r\n        if (!userId) return;\r\n\r\n        if (usingLocal) {\r\n            const updatedConvs = conversations.filter(c => c.id !== conversationId);\r\n            localStorage.setItem(`conversations_${userId}`, JSON.stringify(updatedConvs));\r\n            setConversations(updatedConvs);\r\n            localStorage.removeItem(`messages_${conversationId}`);\r\n        } else {\r\n            try {\r\n                // Delete messages subcollection (client-side manual delete)\r\n                const messagesRef = collection(db, 'users', userId, 'conversations', conversationId, 'messages');\r\n                const snapshot = await getDocs(messagesRef);\r\n                const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));\r\n                await Promise.all(deletePromises);\r\n\r\n                // Delete conversation doc\r\n                await deleteDoc(doc(db, 'users', userId, 'conversations', conversationId));\r\n            } catch (error) {\r\n                console.error(\"Error deleting conversation:\", error);\r\n            }\r\n        }\r\n\r\n        // If the deleted conversation was active, reset\r\n        if (currentConversationId === conversationId) {\r\n            setCurrentConversationId(null);\r\n            conversationIdRef.current = null;\r\n            setMessages([]);\r\n        }\r\n    };\r\n\r\n    return { \r\n        conversations, \r\n        currentConversationId, \r\n        messages, \r\n        loading, \r\n        saveMessage, \r\n        startNewConversation, \r\n        selectConversation,\r\n        deleteConversation\r\n    };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}